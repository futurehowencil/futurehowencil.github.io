<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap的put方法</title>
    <url>/2020/04/25/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>趁着有空打算把集合方面比较有意思和重要的知识点都总结一下，因为平时Map集合用得比较多，就从HashMap开始吧</p>
<h3 id="1-HashMap里面一些重要的成员变量"><a href="#1-HashMap里面一些重要的成员变量" class="headerlink" title="1.HashMap里面一些重要的成员变量"></a>1.HashMap里面一些重要的成员变量</h3><img src="/2020/04/25/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95/1.png" class title="HashMap的一些成员变量">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">  * 默认的初始容量-必须为2的幂。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">  * 负载因子，当容量达到总容量的0.75时需要扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">  * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">  * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">  * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">  * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">  * shrinkage.</span></span><br><span class="line"><span class="comment">  * 链表长度到8，就转为红黑树</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">  * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">  * 树大小为6，就转回链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 使用put方法的时候会调用putVal方法 </span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断是table否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// resize方法不仅是字面意思的调整容量，在第一次put的时候还会初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// table的第i个桶中没有元素就直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果table第i个桶有元素，并且p是第一个元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 进行比较，hash值相等并且是（同一个key或者这两个key equals），则新值覆盖旧值</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果table第i个桶是红黑树的话，执行红黑树插入的方法</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是红黑树，那就一定是链表了。这里会遍历整个链表</span></span><br><span class="line">            <span class="comment">// binCount 计数链表的节点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遍历到链表最后，在链表尾部添加一个节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/* TREEIFY_THRESHOLD是8，binCount的初始值是0，</span></span><br><span class="line"><span class="comment">                     * 添加一个节点后，如果binCount&gt;=7 也就是有8个节点时会转变成红黑树</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在遍历时，其中一个key的hash值相等并且是（同一个key或者这两个key equals），则新值覆盖旧值，并且break结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 在put方法里传入的onlyIfAbsent是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 新值覆盖旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值，方法结束。因为覆盖旧值的话，结构和size没有变化，下面的代码不用执行</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount记录的是，HashMap结构修改的次数。（覆盖旧值不算，因为覆盖旧值的话方法在上面已经结束了</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 插入一个key-value之后，如果此时的size &gt; threshold，进行扩容rezise</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>小小说一下put方法的整个流程</p>
<ol>
<li>初始化table</li>
<li>计算key的hash值，table的第i个桶中没有元素，直接插入</li>
<li>如果第i个桶中有元素，并且满足条件，就进行新值覆盖旧值</li>
<li>如果第i个桶是TreeNode红黑树，则执行方法putTreeVal进行树的插入操作</li>
<li>如果第i个桶是链表，则遍历链表。如果key的hash值相等，并且（为同一个key||两个key equals）则覆盖旧值，break跳出循环。如果不等，则在链表的尾部进行插入newNode。如果插入之后链表长度大于8，则转成红黑树。</li>
<li>如果size &gt; threshold，进行扩容</li>
</ol>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8-Lambda表达式学习</title>
    <url>/2020/04/12/Java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Lambda表达式是Java 8的新特性，也更新了好久，但是感觉并不是很常见?（可能是我的错觉），但好像使用频率有增长的势头。因为我自己也很少使用，利用一下周末时间来学习一下。</p>
<h3 id="1-关于Lambda-表达式"><a href="#1-关于Lambda-表达式" class="headerlink" title="1.关于Lambda 表达式"></a>1.关于Lambda 表达式</h3><ul>
<li>Lambda 表达式允许函数作为一个方法的参数</li>
<li>熟练使用Lambda 表达式可以使代码变得更加简洁优雅（可以少写）</li>
<li>一般用于简化匿名内部类，被称为函数式接口的概念（函数式接口也就是只具有一个抽象方法的普通接口，这个应该属于它的缺点了… 有局限性）</li>
</ul>
<a id="more"></a>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>一般的语法格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression  <span class="comment">// （参数）-&gt; 表达式</span></span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line">（parameters) -&gt; &#123; statements; &#125; <span class="comment">// (参数) -&gt; 方法体</span></span><br></pre></td></tr></table></figure>

<p>Lambda 表达式的几个特征</p>
<ul>
<li>不需要声明参数类型</li>
<li>一个参数时，不需要圆括号；多个参数需要</li>
<li>方法体只有一条语句时不需要花括号；多条语句需要</li>
<li>如果只有一个返回值会自动返回，不需要写return</li>
</ul>
<h3 id="2-使用Lambda-表达式的例子"><a href="#2-使用Lambda-表达式的例子" class="headerlink" title="2.使用Lambda 表达式的例子"></a>2.使用Lambda 表达式的例子</h3><ul>
<li>关于匿名内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经常使用的匿名内部类 例如排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">"abcdfg"</span>);</span><br><span class="line">        list1.add(<span class="string">"123456789"</span>);</span><br><span class="line">        list1.add(<span class="string">"ABCJKLQW"</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list1 排序前："</span>+list1);</span><br><span class="line">        System.out.println(<span class="string">"list2 排序前："</span>+list2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8之前</span></span><br><span class="line">        list1.sort(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.length() - b.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// java 8之后，使用Lambda 表达式</span></span><br><span class="line">        list2.sort((a,b) -&gt; a.length()-b.length());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list1 排序后："</span>+list1);</span><br><span class="line">        System.out.println(<span class="string">"list2 排序后："</span>+list2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后打印输出的结果是一样的</p>
<img src="/2020/04/12/Java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/1.png" class title="打印输出的结果">



<ul>
<li>无参数无返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaMessage m1 = <span class="keyword">new</span> LambdaMessageImpl();</span><br><span class="line">        <span class="comment">// Java 8之前传统方法</span></span><br><span class="line">        m1.printMessage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类方式</span></span><br><span class="line">        LambdaMessage m2 = <span class="keyword">new</span> LambdaMessage() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"输出信息:匿名内部类"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        m2.printMessage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式, 使用lambda表达式</span></span><br><span class="line"><span class="comment">//        LambdaMessage m3 = () -&gt; &#123;System.out.println("输出信息:使用Lambda表达式");&#125;;</span></span><br><span class="line">        LambdaMessage m3 = () -&gt; System.out.println(<span class="string">"输出信息:使用Lambda表达式"</span>);</span><br><span class="line">        m3.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">LambdaMessage</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LambdaMessageImpl</span> <span class="keyword">implements</span> <span class="title">LambdaMessage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/12/Java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/2.png" class title="打印输出结果">

<ul>
<li>有参有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无参无返回值</span></span><br><span class="line">        WhereGo go = () -&gt; System.out.println(<span class="string">"下楼吃饭"</span>);</span><br><span class="line">        go.go();</span><br><span class="line">        <span class="comment">//有参无返回值</span></span><br><span class="line">        WhoTalkSomething wts = ((person, content) -&gt; System.out.println(person + <span class="string">"说"</span> + content));</span><br><span class="line">        wts.talk(<span class="string">"我"</span>, <span class="string">"饿了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参数有返回值</span></span><br><span class="line"><span class="comment">//        CalcResult result = (int a,int b) -&gt;&#123; return a + b;&#125;; // 参数类型可不写</span></span><br><span class="line"><span class="comment">//        CalcResult result = (a, b) -&gt; &#123;return a+b;&#125;; // 可以省略花括号+return</span></span><br><span class="line">        CalcResult result = (a, b) -&gt; a + b;</span><br><span class="line">        System.out.println(<span class="string">"计算结果:"</span> + result.add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WhereGo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WhoTalkSomething</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String person, String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CalcResult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/12/Java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/3.png" class title="打印输出结果">

<ul>
<li>关于参数的使用简单说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lambda表达式可以使用外部的局部变量</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">        ParamClass paramClass = (a, b) -&gt; System.out.println(num1+num2);</span><br><span class="line">        <span class="comment">// num1 = 1; 会编译报错 Variable used in lambda expression should be final or effectively final </span></span><br><span class="line">        <span class="comment">// 这里的外部局部变量可以不声明final 但不可修改(隐性final)</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 外部的局部变量不可与lambda表达式中的变量名相同</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">4</span>;</span><br><span class="line">        ParamClass paramClass1 = (a,w) -&gt; System.out.println(a+c);</span><br><span class="line">   		<span class="comment">// 这里的局部变量a与入参a名字相同, 会编译报错 Variable 'a' is already defined in the scope</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ParamClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习完这个打算再学习一下Steam流</p>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8-Stream流学习</title>
    <url>/2020/04/12/Java8-Stream%E6%B5%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java-8-Steam学习"><a href="#Java-8-Steam学习" class="headerlink" title="Java 8-Steam学习"></a>Java 8-Steam学习</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Stream流是Java8的新特性，简化了很多代码，使代码看起来相对优雅。对集合（Colletion）对象功能增强。</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下安装redis</title>
    <url>/2020/04/06/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<h2 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h2><p>前提：我自己的Linux是在阿里云上的</p>
<h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>在Linux里下载很方便，直接运行下面这条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>版本号在最后面 例如想安装4.0.8的，可以修改一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.8.tar.gz</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-解压编译安装"><a href="#2-解压编译安装" class="headerlink" title="2.解压编译安装"></a>2.解压编译安装</h3><p>执行解压命令就ok</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">　tar xzvf redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压完成后进入文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.5</span><br><span class="line">//编译</span><br><span class="line">make</span><br><span class="line">// 进入src安装</span><br><span class="line">cd src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>如图所示就是安装好了</p>
<img src="/2020/04/06/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/Snipaste_2020-04-06_14-10-50.png" class>

<h3 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h3><p>创建一个bin和etc文件夹，方便管理。执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir bin</span><br><span class="line">mkdir etc</span><br></pre></td></tr></table></figure>

<p>在解压好的redis-5.0.5文件夹里有<code>redis.conf</code>文件，将其复制移动到etc文件夹内</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv redis.conf /redis/redis-5.0.5/etc/</span><br></pre></td></tr></table></figure>

<p>进入src文件夹内，将mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server移动到我们刚创建好的bin文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server &#x2F;redis&#x2F;redis-5.0.5&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>进入bin和etc可以看到刚刚移动过来的文件</p>
<img src="/2020/04/06/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/Snipaste_2020-04-06_14-19-28.png" class>

<h4 id="4-设置后台启动Redis"><a href="#4-设置后台启动Redis" class="headerlink" title="4.设置后台启动Redis"></a>4.设置后台启动Redis</h4><p>编辑<code>redis.conf</code>文件 将daemonize属性改为yes（表明需要在后台运行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd etc/</span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure>

<img src="/2020/04/06/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/Snipaste_2020-04-06_14-23-12.png" class>

<p>修改完成后，再次启动redis并指定配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-server /redis/redis-5.0.5/etc/redis.conf</span><br></pre></td></tr></table></figure>

<img src="/2020/04/06/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/Snipaste_2020-04-06_14-26-14.png" class>

<p>可以试着链接客户端或者查看进程进行验证</p>
<h4 id="5-连接阿里云上的Redis"><a href="#5-连接阿里云上的Redis" class="headerlink" title="5.连接阿里云上的Redis"></a>5.连接阿里云上的Redis</h4><p>需要修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br><span class="line">修改成</span><br><span class="line">bind 0.0.0.0 代表任意IP</span><br><span class="line">一般的版本号比较新的还需要修改</span><br><span class="line">protected-mode no 改成 protected-mode yes</span><br></pre></td></tr></table></figure>

<p>最后记得将阿里云的安全组开放redis端口</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2020/05/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><ul>
<li><strong>进程：</strong>进程是程序的一次执行过程，是系统运行程序的基本单位。进程的生命周期是创建、运行、消亡。</li>
</ul>
<p>打开Windows的任务管理器，就可以看到很多在运行的进程。</p>
<img src="/2020/05/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1.png" class>

<ul>
<li><strong>线程：</strong>线程和进程类似，进程有许多线程来组成。与进程不同，线程共享<strong>堆</strong>和<strong>方法区</strong>的资源，但每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong> 。</li>
</ul>
<p><em>进程由多个线程来组成。各个线程之间的独立存在的，而线程则不一定。线程有可能会互相影响，线程执行开销小，不利于资源的保护，而进程刚好相反。</em></p>
<a id="more"></a>

<h4 id="程序计数器、虚拟机栈、本地方法栈为什么是私有的？"><a href="#程序计数器、虚拟机栈、本地方法栈为什么是私有的？" class="headerlink" title="程序计数器、虚拟机栈、本地方法栈为什么是私有的？"></a>程序计数器、虚拟机栈、本地方法栈为什么是私有的？</h4><ul>
<li>程序计数器：</li>
</ul>
<p>1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</p>
<p>2.在多线程时，计数器用来记录当前线程所执行到的位置，确保下次线程切换后能恢复到正确的执行位置。</p>
<ul>
<li>虚拟机栈：每个Java方法在执行时，会将局部变量，常量池引用等信息存储在虚拟机栈中。</li>
<li>本地方法栈：和虚拟机栈类似，虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈为虚拟机执行Native方法服务。</li>
</ul>
<p>为了保证线程中的局部变量不被其他线程访问到，所以虚拟机栈和本地方法栈是私有的。</p>
<h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><ul>
<li><strong>堆：</strong>用于存放新创建的对象</li>
<li><strong>方法区：</strong>用于存放被加载的类信息、常量、静态变量等。</li>
</ul>
<h3 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2.线程的生命周期"></a>2.线程的生命周期</h3><ul>
<li><strong>初始状态（NEW）：</strong>线程被构建，但是还没有调用start()方法。</li>
<li><strong>运行状态（RUNNABLE）：</strong>包括线程就绪和运行。</li>
<li><strong>阻塞状态（BLOCKED）：</strong>线程被锁阻塞。</li>
<li><strong>等待状态（WAITING）：</strong>当前线程需要等待其他线程完成一些特定动作（例如通知或者中断）。</li>
<li><strong>超时等待状态（TIME_WATING）：</strong>不同于WAITING，它可以在指定的时间自行返回。</li>
<li><strong>终止状态（TERMINATED）：</strong>当前线程已经执行完毕。</li>
</ul>
<h3 id="3-线程死锁"><a href="#3-线程死锁" class="headerlink" title="3.线程死锁"></a>3.线程死锁</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源释放。由于线程被阻塞，因此程序不可能正常终止。</p>
<p>一个死锁的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ObjectA"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wait ObjectB"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"ge6t ObjectB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ObjectB"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wait ObjectA"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ObjectA"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制台输出内容</span></span><br><span class="line">Thread[线程<span class="number">1</span>,<span class="number">5</span>,main]get ObjectA</span><br><span class="line">Thread[线程<span class="number">2</span>,<span class="number">5</span>,main]get ObjectB</span><br><span class="line">Thread[线程<span class="number">1</span>,<span class="number">5</span>,main]wait ObjectB</span><br><span class="line">Thread[线程<span class="number">2</span>,<span class="number">5</span>,main]wait ObjectA</span><br></pre></td></tr></table></figure>

<p>2个线程各自开始获取对方的资源，并对自身所获取的资源保持不放，就会一直等待下去，这就造成了死锁。</p>
<h4 id="产生死锁的4个条件"><a href="#产生死锁的4个条件" class="headerlink" title="产生死锁的4个条件"></a>产生死锁的4个条件</h4><ul>
<li><em>互斥条件：</em>一个资源在任意时刻只能被一个线程占用。</li>
<li><em>请求与保持条件：</em>一个进程因请求资源而阻塞时，对自身获得的资源保持不放。</li>
<li><em>不可剥夺条件：</em>线程已获得的资源在使用完毕之前不能被其他线程获取，只有自己使用完毕后才释放资源。</li>
<li><em>循环等待条件：</em>若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>破坏上述4个条件之一。</p>
<ol>
<li><em>破坏互斥条件：</em>使用锁的目的就是互斥，这个没办法破坏。</li>
<li><em>破坏请求与保持条件：</em>一个线程一次获取到所以资源。</li>
<li><em>破坏不可剥夺条件：</em>获得资源的线程在尝试获取其他资源时，若获取不到，释放自身获取到的资源。</li>
<li><em>破坏循环等待条件：</em>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
</ol>
<p>破坏不可剥夺条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ObjectA"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wait ObjectB"</span>);</span><br><span class="line">                <span class="comment">// 判断是否获取到</span></span><br><span class="line">                <span class="keyword">if</span> (!Thread.holdsLock(objectB)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取不到则释放已有资源</span></span><br><span class="line">                        objectA.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ObjectB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"2get ObjectB"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"2wait ObjectA"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    objectA.notifyAll();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"2get ObjectA"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>破坏循环等待条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ObjectA"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wait ObjectB"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ObjectB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按顺序来获取</span></span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"2get ObjectB"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"2wait ObjectA"</span>);</span><br><span class="line">                <span class="comment">// 按顺序来获取</span></span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"2get ObjectA"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-sleep-方法和wait-方法"><a href="#4-sleep-方法和wait-方法" class="headerlink" title="4.sleep()方法和wait()方法"></a>4.sleep()方法和wait()方法</h3><ul>
<li>sleep()方法没有释放锁，wait()方法释放锁。</li>
<li>两个方法都可以暂停线程的执行。</li>
<li>sleep()方法用于暂停线程的执行，wait()用于线程之间的交互/通信。</li>
<li>sleep()方法被调用后，到时间线程会自动苏醒。</li>
<li>wait()方法被调用后，需要别的线程调用同一对象上的notify()方法或者notifyAll()方法唤醒线程。或者使用wait(long timeout)超时后线程会自动苏醒</li>
</ul>
<h3 id="5-run-方法和start-方法"><a href="#5-run-方法和start-方法" class="headerlink" title="5.run()方法和start()方法"></a>5.run()方法和start()方法</h3><p><strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
<p><strong>使用start()方法才是真正的多线程。</strong></p>
<h3 id="6-synchronized关键字"><a href="#6-synchronized关键字" class="headerlink" title="6.synchronized关键字"></a>6.synchronized关键字</h3><p>synchronized是解决多个线程之间访问资源的同步性，它可以保证被修饰的方法或者代码块在任意时刻只能有一个线程在执行。</p>
<p><strong>synchronized的使用方法：</strong></p>
<ul>
<li><strong>修饰实例方法：</strong>给当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li>
<li><strong>修饰静态方法：</strong>给当前类加锁，作用于类的所有对象实例。值得注意的是，如果线程A调用实例对象的非静态synchronized方法，线程B调用该实例对象的类的静态synchronized方法，两者不会互斥。</li>
<li><strong>修饰代码块：</strong>指定加锁对象，对给定对象加锁。进入同步代码块前要获得给定对象的锁。</li>
</ul>
]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引失效的几种场景</title>
    <url>/2020/06/02/MySql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="1-索引失效的场景"><a href="#1-索引失效的场景" class="headerlink" title="1.索引失效的场景"></a>1.索引失效的场景</h3><ol>
<li>like查询以<code>%</code>开头，索引失效；以<code>%</code>结尾，索引有效。</li>
<li>or语句前后没有同时使用索引。</li>
<li>组合索引，不是使用第一列索引时失效。（例如组合索引为A，B，C，AB、AC索引有效，BC索引无效）</li>
<li>在索引字段上使用操作符。</li>
<li>对索引字段使用计算操作。</li>
<li>在索引字段上使用函数。</li>
<li>当全局扫描比索引速度快时，MySQL使用全局扫描而非索引。</li>
</ol>
<h3 id="2-查看索引分析"><a href="#2-查看索引分析" class="headerlink" title="2.查看索引分析"></a>2.查看索引分析</h3><p>在将要执行的SQL语句前加上explain命令。</p>
<p>执行结果中，如果看到key这一列上为NULL，则没有使用索引。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架</title>
    <url>/2020/05/27/Mybatis%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="1-什么是Mybatis"><a href="#1-什么是Mybatis" class="headerlink" title="1.什么是Mybatis"></a>1.什么是Mybatis</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。—— 摘录官网</p>
<p><strong>为什么要使用Mybatis？</strong></p>
<p>在传统的JDBC中，除了要自己编写SQL语句外，还需要操作Connection、Statement、ResultSet。在访问多个表的时候，就会出现很多重复的代码。代码不仅繁琐且枯燥。</p>
<p>使用了Mybatis后，开发的过程中只需SQL语句即可，提高了开发效率。</p>
<a id="more"></a>

<h3 id="2-Mybatis使用步骤"><a href="#2-Mybatis使用步骤" class="headerlink" title="2.Mybatis使用步骤"></a>2.Mybatis使用步骤</h3><ol>
<li>配置mybatis-config.xml全局配置文件</li>
<li>创建SqlSessionFactory</li>
<li>通过SqlSessionFactory创建SqlSession对象</li>
<li>通过SqlSession对象操作数据库</li>
<li>调用session.commit()提交事务</li>
<li>调用session.close()关闭会话</li>
</ol>
<h3 id="3-关于Mybatis的一些问题"><a href="#3-关于Mybatis的一些问题" class="headerlink" title="3.关于Mybatis的一些问题"></a>3.关于Mybatis的一些问题</h3><p><strong>#{}和${}的区别是什么？</strong></p>
<p><code>#</code>等于是对数据加上双引号（预编译），<code>$</code>    等于是直接显示数据。</p>
<ul>
<li><strong>#{}</strong>是SQL语句中的参数占位符，Mybatis会将#{}替换成?号。在SQL执行前会使用PrepareStatement按照顺序给?号占位符设置参数值。例如user.name就是利用反射从参数对象获取user对象的name值，等同于param.getUser().getName()。进行了预编译处理，可以防止SQL注入。</li>
<li><strong>${}</strong>是properties文件中的变量占位符，属于静态文本替换。相当于拼接SQL。</li>
</ul>
<p><strong>Mapper接口的工作原理是什么？接口里的方法能否重载？</strong></p>
<ul>
<li><strong>工作原理：</strong>使用的是JDK的动态代理，运行时会为Mapper接口生成Proxy对象，代理对象拦截目标方法并执行。</li>
<li><strong>不可以重载</strong>，因为是全限名+方法名的保存和寻找策略。</li>
</ul>
<p><strong>Mybatis插件的运行原理，如何编写一个插件</strong></p>
<ul>
<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4个接口的插件，使用的是JDK的动态代理。</li>
<li><strong>编写一个Mybatis插件：</strong>实现Mybatis的Interceptor接口并重写intercept()方法，并指定要拦截的哪些接口的哪些方法，最后在配置文件中配置。</li>
</ul>
<p><strong>什么是动态SQL</strong></p>
<p>Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p>
<p><strong>Mybatis和Hibernate的区别？</strong></p>
<ol>
<li>Mybatis为半自动，Hibernate是全自动的。</li>
<li>Hibernate数据库的移植性要大于Mybatis。<strong>Hibernate通过映射结构和hql，降低了和数据库的耦合性；而Mybatis则需要手动编写SQL语句</strong>。</li>
<li>在SQL优化上，Mybatis比Hibernate方便。<strong>Hibernate的SQL是自动生成的，无法直接进行维护</strong>。</li>
</ol>
]]></content>
      <tags>
        <tag>常用框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2020/06/01/SpringBoot/</url>
    <content><![CDATA[<h3 id="1-SpringBoot介绍"><a href="#1-SpringBoot介绍" class="headerlink" title="1.SpringBoot介绍"></a>1.SpringBoot介绍</h3><p>服务于Spring框架的框架，可以简化配置文件，快速构建web应用，内置容器，无需打包部署，直接运行。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>创建独立的Spring应用</li>
<li>嵌入式容器（无需war文件）</li>
<li>提供的starters简化构建配置</li>
<li>尽可能地自动配置</li>
<li>没有代码生成和xml配置要求</li>
</ul>
<h4 id="SpringBoot的核心注解"><a href="#SpringBoot的核心注解" class="headerlink" title="SpringBoot的核心注解"></a>SpringBoot的核心注解</h4><p>SpringBoot的核心注解是<strong>@SpringBootApplication</strong>，本质上由3个注解组成。</p>
<ul>
<li><strong>@Configuration：</strong>实现配置文件的功能。</li>
<li><strong>@EnableAutoConfiguration：</strong>打开自动配置的功能，把所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IOC容器中。</li>
<li><strong>@ComponentScan：</strong>默认扫描当前package下的所有加了@Component、@Controller、@Service、@Repository等注解的类到IOC容器中。</li>
</ul>
]]></content>
      <tags>
        <tag>常用框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2020/06/02/SpringCloud/</url>
    <content><![CDATA[<h3 id="1-什么是SpringCloud"><a href="#1-什么是SpringCloud" class="headerlink" title="1.什么是SpringCloud"></a>1.什么是SpringCloud</h3><p>SpringCloud 是一系列框架的有序集合。它利用 SpringBoot  的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 SpringBoot 的开发风格做到一键启动和部署。</p>
<a id="more"></a>

<h3 id="2-SpringCloud的核心组件"><a href="#2-SpringCloud的核心组件" class="headerlink" title="2.SpringCloud的核心组件"></a>2.SpringCloud的核心组件</h3><ul>
<li><strong>Eureka：</strong>服务注册与发现（注册中心）。</li>
<li><strong>Feign：</strong>声明式服务调用，基于动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。</li>
<li><strong>Ribbon：</strong>客户端负载均衡，从一个服务的多台机器中选择一台。</li>
<li><strong>Hystrix：</strong>断路器，服务容错保护。提供线程池，不同的服务走不同的线程池，实现了不同服务的调用的隔离，避免了服务雪崩的问题。</li>
<li><strong>Zuul：</strong>API网关服务，由Zuul网关转发请求给对应的服务。</li>
<li><strong>Config：</strong>分布式配置中心。</li>
</ul>
<h3 id="3-SpringCloud组件详解"><a href="#3-SpringCloud组件详解" class="headerlink" title="3.SpringCloud组件详解"></a>3.SpringCloud组件详解</h3><ol>
<li><strong>Eureka的治理机制：</strong><ol>
<li><strong>服务提供者：</strong><ul>
<li><strong>服务注册与同步：</strong>启动时会通过REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息（IP+端口等）。并且该注册请求会转发到集群中相连的其他注册中心，实现注册中心之间的服务同步。</li>
<li><strong>服务续约：</strong>注册完成后，服务提供者会维护一个心跳通知Eureka Server自身还在运行，防止被注册中心剔除。</li>
</ul>
</li>
<li><strong>服务消费者：</strong><ul>
<li><strong>获取服务：</strong>服务消费者进行消费时会发送一个REST请求到注册中心获取服务列表，服务列表30s更新一次。</li>
<li><strong>服务调用：</strong>消费者在获取服务清单后，通过服务名获取服务的实例名，和该实例名的元数据（IP+端口等），Eureka底层会通过Ribbon默认采用讯轮的方式进行调用从而实现客户端的负载均衡。</li>
<li><strong>服务下线：</strong>当服务重启或者关闭时，要主动通知注册中心。会发送一个REST请求到注册中心，注册中心收到请求之后就会把服务从注册列表中剔除。</li>
</ul>
</li>
<li><strong>注册中心：</strong><ul>
<li><strong>失效剔除：</strong>默认每隔一段时间（60s）将当前清单中超时（默认90s）没有续约的服务剔除出去。</li>
<li><strong>自我保护：</strong>注册中心在运行期间会统计服务提供者心跳失败的比例，如果这个比例在15分钟之内小于85%。注册中心会将当前服务保护起来，使其不会过期。</li>
</ul>
</li>
</ol>
</li>
<li><strong>Ribbon和Nginx的区别</strong></li>
</ol>
<p>Ribbon服务清单在客户端，Nginx服务清单在服务端。</p>
<ol start="3">
<li><p><strong>Hystrix断路器：</strong></p>
<ol>
<li>对通过第三方客户端的访问的依赖项的延迟和故障进行保护和控制。</li>
<li>在复杂的分布式系统中阻止级联故障。</li>
<li>快速失败，快速恢复。</li>
<li>回退，降级</li>
<li>启用近实时监控、警报和操作控制。</li>
</ol>
<p>有几个重要的参数：<strong>滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</strong></p>
<ul>
<li>每当20个请求中，有50%失败时，断路器就会打开，此时再调用此服务，将会直接返回失败，不再调用远程服务。</li>
<li>直到5秒钟之后，重新检测该触发条件，判断是否把断路器关闭 ，或者继续打开。</li>
</ul>
<p>服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池,当线程达到阈值的时候就启动服务降级,如果其他请求继续访问就直接返回fallback的默认值。</p>
</li>
<li><p><strong>关于Zuul</strong></p>
<ol>
<li>网关一般是应用的入口，做一些公共的与业务无关的校验工作，所以使用Zuul的原因如下：<ol>
<li>作为系统的统一入口。</li>
<li>与服务治理框架相结合，实现自动化的实力维护、以及负载均衡的路由转发。</li>
<li>实现接口的校验和微服务业务逻辑的解耦。</li>
</ol>
</li>
<li>Zuul和Feign有何不同？<ol>
<li>Zuul是路由的是Controller的请求，Feign路由的是Service的请求。</li>
<li>Zuul做最外层请求的负载均衡，Feign做的是Service调用的负载均衡。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-SpringCloud和Dubbo有何不同？"><a href="#4-SpringCloud和Dubbo有何不同？" class="headerlink" title="4.SpringCloud和Dubbo有何不同？"></a>4.SpringCloud和Dubbo有何不同？</h3><ul>
<li>Dubbo的通信机制是RPC，SpringCloud是REST请求。</li>
<li>Dubbo是SOA面向服务的架构，SpringCloud则是把业务系统组件化。</li>
<li>Zookeeper在选举期间注册服务不可用，各个节点之间是主从关系。Eureka各个节点之间是平等的。</li>
</ul>
]]></content>
      <tags>
        <tag>常用框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2020/05/26/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1.什么是Spring"></a>1.什么是Spring</h3><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>Spring最重要的两个特性IOC和AOP</p>
<p><strong>IOC控制反转</strong></p>
<p>IOC是一种设计思想，原本在程序中手动创建对象的控制权，交给Spring来管理。IOC容器就好比是一个工厂，当需要创建一个对象时，只需要配置好文件或者注解即可，无需考虑对象是如何创建的。</p>
<p><strong>AOP面向切面编程</strong></p>
<p>将那些与业务无关的，却为业务模块所共同调用的逻辑或责任（例如事务管理，日志管理等）封装起来，减少系统的重复代码，降低耦合度，有利于代码的可扩展性和可维护性。</p>
<a id="more"></a>

<p>AOP是基于动态代理的，动态代理有两种形式。</p>
<ul>
<li><strong>JDK动态代理：</strong>目标类需要一个代理接口，核心是InvocationHandler接口和Proxy类。</li>
</ul>
<p>1.定义一个InvocationHandler接口的实现类，重写invoke方法</p>
<p>2.将InvocationHandler对象作为参数传入Proxy类的newProxyInstance方法中</p>
<p>3.调用Proxy类的newProxyInstance方法获得动态代理对象</p>
<p>4.通过代理对象调用目标方法</p>
<ul>
<li><strong>CgLib动态代理：</strong>通过继承的方式来做代理，生成一个子类，并覆盖其中的业务方法来实现。（如果该类是final类则无法使用CgLib动态代理。）</li>
</ul>
<p>1.定义一个cglib.proxy.MethodInterceptor接口的实现类，重写intercept方法</p>
<p>2.获取cglib.proxy.Enhancer类的对象</p>
<p>3.调用Enhance对象的setSuperclass方法和setCallback方法，使用create方法获取代理对象</p>
<p>4.通过代理对象调用目标方法</p>
<p><em>Spring默认使用 JDK动态代理，如果没有实现接口则使用CgLib代理。</em></p>
<p><strong>AOP的通知类型：</strong>前置通知、正常返回通知、异常返回通知、返回通知、环绕通知。    </p>
<h3 id="2-关于SpringBean"><a href="#2-关于SpringBean" class="headerlink" title="2.关于SpringBean"></a>2.关于SpringBean</h3><h4 id="1-bean的作用域"><a href="#1-bean的作用域" class="headerlink" title="1.bean的作用域"></a>1.bean的作用域</h4><ul>
<li><strong>singleton：</strong>唯一bean实例，Spring中的bean默认单例。</li>
<li><strong>prototype ：</strong>每次请求都会创建一个新的bean实例。</li>
<li><strong>request ：</strong>每次请求都会创建一个新的bean实例，该bean只在当前的request中有效</li>
<li><strong>session ：</strong>每次请求都会创建一个新的bean实例，该bean只在当前的session中有效</li>
<li><strong>global-session：</strong>全局session作用域。</li>
</ul>
<h4 id="2-SpringBean单例的线程安全问题"><a href="#2-SpringBean单例的线程安全问题" class="headerlink" title="2.SpringBean单例的线程安全问题"></a>2.SpringBean单例的线程安全问题</h4><p>当多个线程操作同一个对象时，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p><strong>解决方法：</strong></p>
<p>1.在Bean中尽量避免定义可变的成员变量（这个应该很少用吧…)</p>
<p>2.在类中定义一个ThreadLocal成员变量，将可变的成员变量保存在ThreadLocal中</p>
<h3 id="3-Spring的传播事务"><a href="#3-Spring的传播事务" class="headerlink" title="3.Spring的传播事务"></a>3.Spring的传播事务</h3><p>分两种：支持当前事务和不支持当前事务。</p>
<ul>
<li><strong>支持当前事务：</strong></li>
</ul>
<p>1.如果存在事务，则加入当前事务。不存在事务，则创建新事务。</p>
<p>2.如果存在事务，则加入当前事务。不存在事务，以非事务的方式进行。</p>
<p>3.如果存在事务，则加入当前事务。不存在事务，则抛出异常。</p>
<ul>
<li><strong>不支持当前事务：</strong></li>
</ul>
<p>1.创建新事务，如果当前存在事务，则将当前事务挂起。</p>
<p>2.以非事务的方式进行，如果当前存在事务，则将当前事务挂起。</p>
<p>3.以非事务的方式进行，如果当前存在事务，则抛出异常。</p>
<h3 id="4-SpringMVC工作流程"><a href="#4-SpringMVC工作流程" class="headerlink" title="4.SpringMVC工作流程"></a>4.SpringMVC工作流程</h3><ol>
<li>客户端发送请求，直接请求到<code>DispatcherServlet</code>前端控制器</li>
<li><code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapping</code>，解析请求对应的<code>Handler</code></li>
<li>解析到对应的<code>Handler</code>（也就是<code>Controller</code>前端控制器）后，开始由<code>HandlerAdapter</code>适配器处理</li>
<li><code>HandlerAdapter</code>会根据<code>Handler</code>来调用真正的处理器来处理请求，并处理对应的业务逻辑</li>
<li>处理器处理业务完毕后，会返回一个<code>ModelAndView</code>对象</li>
<li><code>ViewResolver</code>视图解析器会根据<code>Model</code>和<code>View</code>渲染视图</li>
<li>最后将视图渲染结果返回给客户端</li>
</ol>
<p>在网上找了一张图</p>
<img src="/2020/05/26/Spring%E6%A1%86%E6%9E%B6/1.png" class>

<h3 id="5-Spring所用到的设计模式"><a href="#5-Spring所用到的设计模式" class="headerlink" title="5.Spring所用到的设计模式"></a>5.Spring所用到的设计模式</h3><ul>
<li><strong>工厂模式：</strong>Spring使用工厂模式通过BeanFactory、ApplicationContext创建bean对象</li>
<li><strong>代理模式：</strong>SpringAOP的动态代理</li>
<li><strong>单例模式：</strong>Spring的bean是默认单例的</li>
<li><strong>适配器模式：</strong>SpringMVC用的就是适配器模式适配Controller</li>
</ul>
]]></content>
      <tags>
        <tag>常用框架</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的安装和使用</title>
    <url>/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>这里以阿里云为例（我的操作系统是centOS7）</p>
<h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h3><p>在阿里云上安装docker还是比较简单的，使用脚本安装就好了只需一行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p><strong>设置开机启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<p><strong>查看docker版本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/1.png" class>

<a id="more"></a>

<p><strong>配置阿里的docker镜像加速器</strong></p>
<p>不使用加速器可能会在拉取docker镜像的时候很慢</p>
<p>进入阿里云控制台，在右上方的搜索框输入“容器镜像服务”</p>
<p>直接复制命令粘贴</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/2.png" class>

<h2 id="2-安装docker-mysql"><a href="#2-安装docker-mysql" class="headerlink" title="2.安装docker-mysql"></a>2.安装docker-mysql</h2><p>1.<strong>拉取mysql镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/3.png" class>

<p>2.<strong>查看是否拉取成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/4.png" class>

<p>3.<strong>创建并启动mysql容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p 3306:3306 --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li>-i : 交互式运行容器</li>
<li>-t : 创建伪终端</li>
<li>-p 3306:3306 : 映射容器的3306端口到宿主机的3306端口，外部服务可以通过ip:3306访问mysql</li>
<li>–name : 容器的名称</li>
<li>-e MYSQL_ROOT_PASSWORD=123456 : 设置mysql root用户的密码</li>
<li>-d : 后台运行</li>
</ul>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>看到如图所示，证明安装成功并成功启动</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/5.png" class>

<p>4.<strong>添加安全组</strong></p>
<p>在阿里云控制平台开放3306端口</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/7.png" class>

<p>授权对象：0.0.0.0/0 代表任何ip</p>
<p>（但其实不建议授权任何ip，会存在安全问题。授权自己的ip就好了）</p>
<h3 id="3-安装docker-redis"><a href="#3-安装docker-redis" class="headerlink" title="3.安装docker-redis"></a>3.安装docker-redis</h3><p>和安装mysql大同小异</p>
<p>1.<strong>拉取redis镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure>

<p>latest : 代表最新版本</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/8.png" class>

<p>2.<strong>查看是否拉取成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/9.png" class>

<p>3.<strong>启动并设置密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d --restart&#x3D;always redis:latest redis-server --appendonly yes --requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li>–name :容器的名字</li>
<li>-p : 6979:6979: 映射容器的6979端口到宿主机的3306端口，外部服务可以通过ip:6979访问redis</li>
<li>-d : 后台运行</li>
<li>–restart : 重启策略 always随着docker容器的启动而启动</li>
<li>redis-servier : 启动命令</li>
<li>–appendonly : redis持久化配置</li>
<li>–requirepass : 密码</li>
</ul>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>看到如图所示则证明成功</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/10.png" class>

<p>4.<strong>添加安全组</strong></p>
<p>进入阿里云控制台开放6379端口</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/11.png" class>

<p>授权对象：0.0.0.0/0 代表任何ip</p>
<p>（不建议授权任何ip，会存在安全问题。授权自己的ip就好了）</p>
<h3 id="4-安装docker-mongo"><a href="#4-安装docker-mongo" class="headerlink" title="4.安装docker-mongo"></a>4.安装docker-mongo</h3><p>1.<strong>拉取镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure>

<p>默认最新版本</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/12.png" class>

<p>2.<strong>查看是否拉取成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/13.png" class>

<p>3.<strong>启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mongoDB -p 27017:27017 -d mongo --auth</span><br></pre></td></tr></table></figure>

<p>命令含义和之前差不多，就不解释了。</p>
<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/14.png" class>

<p>4.<strong>设置密码</strong></p>
<p>首先进入容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID mongo admin</span><br></pre></td></tr></table></figure>

<p>创建用户和密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123; user: 'admin', pwd: '123', roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] &#125;);</span><br></pre></td></tr></table></figure>

<p>验证密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.auth("admin","123");</span><br></pre></td></tr></table></figure>

<img src="/2020/05/07/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/15.png" class>

<p>最后输入<code>exit</code>退出</p>
<p>5.<strong>添加安全组</strong></p>
<p>和之前一样，就不对赘述了。</p>
<p>目前就安装这么多，后续有需要再更新</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo博客如何自定义域名</title>
    <url>/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h2 id="hexo博客自定义域名"><a href="#hexo博客自定义域名" class="headerlink" title="hexo博客自定义域名"></a>hexo博客自定义域名</h2><h3 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h3><p>这里以阿里云为例。</p>
<p>在搜索框输入自己想要的域名，之后点击查询，在下放选择自己想要的域名购买就好了</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/1.png" class>

<a id="more"></a>

<p>提交订单的时候，选择个人或者企业。我选择的是个人，需要一个通过实名认证的信息模板，如果没有就创建一个。</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/2.png" class>

<p>实名认证通过之后就是这个样子了</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/3.png" class>

<p>之后再重复购买步骤。</p>
<h3 id="2-添加CNAME文件"><a href="#2-添加CNAME文件" class="headerlink" title="2.添加CNAME文件"></a>2.添加CNAME文件</h3><p>在本地博客根目录下，有一个source文件夹，</p>
<p>进入source文件夹，创建一个CNAME文件，注意这个文件是没有后缀的。</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/4.png" class>

<p>之后打开CNAME，把刚刚购买的域名填进去</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/5.png" class>

<h3 id="3-在GitHub中设置"><a href="#3-在GitHub中设置" class="headerlink" title="3.在GitHub中设置"></a>3.在GitHub中设置</h3><p>打开GitHub上的博客项目，点击Setting，往下拉找到Custom domain</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/6.png" class>

<h3 id="4-给域名添加解析记录"><a href="#4-给域名添加解析记录" class="headerlink" title="4.给域名添加解析记录"></a>4.给域名添加解析记录</h3><p>首先要ping一下博客地址，地址就是yourname.github.io</p>
<p>以Windows系统为例，打开CMD</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/7.png" class>

<p>红色框起来的部分就是IP地址</p>
<p>打开阿里云控制台，进入域名列表</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/8.png" class>

<p>点击解析，添加两条记录</p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/9.png" class>

<p>——后续更新：</p>
<p>GitHub官方建议的方式是使用CNAME将你的域名解析到 yourname.github.io </p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/10.png" class>

<p>所以我把前两个删掉了</p>
<h3 id="5-开启https"><a href="#5-开启https" class="headerlink" title="5.开启https"></a>5.开启https</h3><p>设置好以后，一般是通过http访问。</p>
<p>在GitHub项目的setting中，有一个选项Enforce HTTPS </p>
<img src="/2020/06/06/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/6.png" class>

<p>一开始这个选项是不能勾选的，要等待证书颁发</p>
<p>证书颁发下来以后，将这个选项勾选上，就可以通过https进行访问了。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一个完整的HTTP请求过程</title>
    <url>/2020/05/21/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>当在浏览器地址栏输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 时，发生了什么</p>
<h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h3><p>1.首先对网址进行DNS域名解析，得到对应的IP地址</p>
<p>2.根据得到的IP地址，找到服务器，发起TCP三次握手</p>
<p>3.成功建立TCP连接后，发起HTTP请求</p>
<p>4.服务器相应HTTP请求，返回html代码</p>
<p>5.浏览器解析html代码，并请求html代码中的资源，例如css，js，图片等。</p>
<p>6.浏览器对页面进行渲染呈现</p>
<a id="more"></a>

<h3 id="3-各个步骤的细节"><a href="#3-各个步骤的细节" class="headerlink" title="3.各个步骤的细节"></a>3.各个步骤的细节</h3><h4 id="1-DNS域名解析"><a href="#1-DNS域名解析" class="headerlink" title="1.DNS域名解析"></a>1.DNS域名解析</h4><p>1.浏览器首先会搜索自身的DNS缓存</p>
<p>2.若自身缓存里没有找到，就会去搜索系统中的DNS缓存</p>
<p>3.若系统的DNS缓存没有找到，就会尝试在hosts文件中查找</p>
<p>4.若在hosts文件中还是没有，会先去本地配置的DNS服务器中查找</p>
<p>5.若本地配置的DNS服务器没有，再来是com的顶级域名服务器</p>
<p>6.若在com域名服务器中没有，最后就会去baidu.com的域名服务器中查找</p>
<h4 id="2-TCP三次握手"><a href="#2-TCP三次握手" class="headerlink" title="2.TCP三次握手"></a>2.TCP三次握手</h4><h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p>因为计算机之间通信是通过协议来实现，协议不同是不能进行通信的。三次握手是保证了协议一致（3次是最少的认知次数）。</p>
<h4 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3.发起HTTP请求"></a>3.发起HTTP请求</h4><p>HTTP请求分为3个部分，请求行、请求头、请求正文</p>
<ul>
<li><p><strong>请求行：</strong>用于描述客户端的请求方式（例如GET、POST等），请求URL以及使用的HTTP协议的版本号。比如GET/index.html HTTP/1.1</p>
</li>
<li><p><strong>请求头：</strong>请求头是告知服务器关于客户端（浏览器）的请求信息。</p>
</li>
<li><p><strong>请求正文：</strong>请求正文就是客户端（浏览器）向服务器传递的数据。（有一些请求是不需要请求正文的，例如GET请求可以没有请求正文）</p>
</li>
</ul>
<p>一般的请求方式有：</p>
<ul>
<li><em>GET：</em>完整请求一个资源</li>
<li><em>POST：</em>提交表单</li>
<li><em>HEAD：</em>仅请求响应头部</li>
<li><em>PUT：</em>上传文件</li>
<li><em>DELETE：</em>删除</li>
<li><em>OPTIONS：</em>预请求，即试探性的请求，如果遭到拒绝，则不会发起第二次请求</li>
</ul>
<h4 id="4-服务器响应HTTP请求"><a href="#4-服务器响应HTTP请求" class="headerlink" title="4.服务器响应HTTP请求"></a>4.服务器响应HTTP请求</h4><p>HTTP响应同样分为3个部分，响应行、响应头、响应正文</p>
<ul>
<li><strong>响应行：</strong>一般有协议版本号、状态码、描述组成。例如HTTP/200 OK</li>
<li><strong>响应头：</strong>返回服务器的基本信息，以及告知客户端如何处理数据</li>
<li><strong>响应体：</strong>就是响应的消息体，一般就是数据或者html代码</li>
</ul>
<p><strong>状态码：</strong></p>
<ul>
<li><em>1xx：</em>提示信息，表示请求已收到，继续处理</li>
<li><em>2xx：</em>成功，请求被成功接收并完成整个处理过程。一般为200</li>
<li><em>3xx：</em>重定向，要完成请求必须要进行进一步的操作。一般有302重定向至新的资源地址</li>
<li><em>4xx：</em>客户端请求错误，404表示请求的资源在服务器中没有，403服务器拒绝访问</li>
<li><em>5xx：</em>服务端错误，一般用500服务器发生错误，503服务器不能处理这个请求</li>
</ul>
<h4 id="5-解析html代码并请求html代码中的资源"><a href="#5-解析html代码并请求html代码中的资源" class="headerlink" title="5.解析html代码并请求html代码中的资源"></a>5.解析html代码并请求html代码中的资源</h4><p>若有css、js、图片等静态资源，就会向服务器下载。</p>
<h4 id="6-浏览器对页面进行渲染呈现"><a href="#6-浏览器对页面进行渲染呈现" class="headerlink" title="6.浏览器对页面进行渲染呈现"></a>6.浏览器对页面进行渲染呈现</h4><p>这里就是浏览器自己的工作机制了，对已获得的静态资源和html代码进行渲染并呈现给用户。</p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历、中序遍历、后序遍历</title>
    <url>/2020/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树的前序遍历、中序遍历、后序遍历"><a href="#二叉树的前序遍历、中序遍历、后序遍历" class="headerlink" title="二叉树的前序遍历、中序遍历、后序遍历"></a>二叉树的前序遍历、中序遍历、后序遍历</h2><p>简单讲一下三种遍历方式</p>
<ul>
<li>前序：根 - &gt; 左 - &gt;  右</li>
<li>中序：左 - &gt; 根 - &gt; 右</li>
<li>后序：左 - &gt; 右 - &gt; 根</li>
</ul>
<p><strong>其实再复杂的二叉树都可以拆分成3个节点的二叉树一步一步遍历</strong></p>
<a id="more"></a>

<h3 id="简单的二叉树"><a href="#简单的二叉树" class="headerlink" title="简单的二叉树"></a>简单的二叉树</h3><img src="/2020/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/1.png" class>

<ul>
<li>前序：ABC</li>
<li>中序：BAC</li>
<li>后序：BCA</li>
</ul>
<img src="/2020/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/2.png" class>

<ul>
<li>前序：ABDECFG</li>
</ul>
<p>(可以拆分成多个有3个节点的小二叉树)</p>
<p>首先A为根节点，有左子树B，右子树C</p>
<p>B可以作为下一级的根节点，有左子树D，右子树E</p>
<p>A根节点的右子树C同理</p>
<p>最后就是ABDECFG</p>
<ul>
<li>中序：DBEAFCG</li>
</ul>
<p>首先是B A C，</p>
<p>B下面还有子树，所以是D B E A C，</p>
<p>C下面还有子树，所以最后是DBEAFCG</p>
<ul>
<li>后序：DEBFGCA</li>
</ul>
<p>首先是 B C A，</p>
<p>B下面还有子树，所以是D E B C A，</p>
<p>C下面还有子树，所以最后是DEBFGCA</p>
<h3 id="不规则的二叉树"><a href="#不规则的二叉树" class="headerlink" title="不规则的二叉树"></a>不规则的二叉树</h3><p>上面的二叉树是左右对称的二叉树。</p>
<p>现在画一个不对称的二叉树</p>
<img src="/2020/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/3.png" class>

<ul>
<li>前序：ABDEGHCF</li>
</ul>
<p>首先是A B C，B下面还有子树，所以是A B D E C</p>
<p>E下面还有子树，所以是A B D E G H C</p>
<p>C下面还有子树，最后就是ABDEGHCF</p>
<ul>
<li>中序：DBGEHACF</li>
</ul>
<p>首先是B A C，B下面还有子树，所以是D B E A C</p>
<p>E下面还有子树，所以是D B G E H A C</p>
<p>C下面还有子树，最后就是DBGEHACF</p>
<ul>
<li>后序：DGHEBFCA</li>
</ul>
<p>首先是B C A，B下面还有子树，所以是D E B C A </p>
<p>E下面还有子树，所以是D G H E B C A </p>
<p>C下面还有子树，所以是DGHEBFCA</p>
<h3 id="根据三种排序中的两种排序画出二叉树（中序必须有）"><a href="#根据三种排序中的两种排序画出二叉树（中序必须有）" class="headerlink" title="根据三种排序中的两种排序画出二叉树（中序必须有）"></a>根据三种排序中的两种排序画出二叉树（中序必须有）</h3><p>想要知道二叉树的结构，中序是必不可少的。因为没有中序无法知道左右子树。</p>
<p><strong>如果已知中序遍历是DBEAFC，前序遍历是ABDECF，求后序遍历</strong></p>
<ol>
<li><p>可以确定A是根节点</p>
</li>
<li><p>A根节点下面，左子树有DBE，右子树有FC</p>
</li>
<li><p>根据前序BDE，中序DBE，得知B是次级根节点，左子树是D，右子树是E</p>
</li>
<li><p>F C、C F，根据排序方式可以得出结论，C是次级根节点，左子树是F（中序遍历F出现在C前面所以是左子树，如果F出现的C后面，那F就是C的右子树），无右子树</p>
<img src="/2020/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/4.png" class title="二叉树图示">
</li>
<li><p>所以后序遍历就是DEBFCA</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>再把所说的排序方式深入总结一下</p>
<ol>
<li><strong>前序遍历：首先访问根节点，再遍历左子树，最后遍历右子树。在遍历左、右子树时，也是先访问根节点，再遍历左子树，最后遍历右子树。</strong></li>
<li><strong>中序遍历：首先遍历左子树，然后访问根节点，最后遍历右子树。在遍历左、右子树时，也是先遍历左子树，然后访问根节点，最后遍历右子树。</strong></li>
<li><strong>后序遍历：首先遍历左子树，再遍历右子树，最后访问根节点。在遍历左、右子树时，也是先遍历左子树，再遍历右子树，最后访问根节点。</strong></li>
</ol>
<p>也就是不断地递归</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用redis监听订单</title>
    <url>/2020/04/25/%E4%BD%BF%E7%94%A8redis%E7%9B%91%E5%90%AC%E8%AE%A2%E5%8D%95/</url>
    <content><![CDATA[<h2 id="使用redis监听订单"><a href="#使用redis监听订单" class="headerlink" title="使用redis监听订单"></a>使用redis监听订单</h2><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h3><p>一般在淘宝之类的购物网站买东西，在下单以后，支付之前会有一个订单有效期。</p>
<h3 id="2-大概流程"><a href="#2-大概流程" class="headerlink" title="2.大概流程"></a>2.大概流程</h3><ol>
<li>点击下单，发送请求。生成订单信息，保存到数据库中，初始化支付状态（可以是0）。同时把订单信息存入redis。以订单号orderId作为redis的key（值可以随便设置），并且设置过期时间（也就是订单的有效期）。</li>
<li>在订单过期之前。如果用户付款成功的话，支付宝或者微信支付之类的回调接口会修改订单的支付状态为成功。</li>
<li>到了过期时间，redis监听器监听到了过期的key，取出key(也就是orderId)到数据库中查询该订单的支付状态。如果支付状态不是成功，则修改支付状态为失败（成功可以为1，失败则为2）。</li>
</ol>
<a id="more"></a>

<h3 id="3-实现代码（简单模拟）"><a href="#3-实现代码（简单模拟）" class="headerlink" title="3.实现代码（简单模拟）"></a>3.实现代码（简单模拟）</h3>]]></content>
      <tags>
        <tag>工作有感</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始-用hexo和GitHub搭建个人博客</title>
    <url>/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="用hexo和GitHub搭建个人博客"><a href="#用hexo和GitHub搭建个人博客" class="headerlink" title="用hexo和GitHub搭建个人博客"></a>用hexo和GitHub搭建个人博客</h2><h4 id="1-首先安装Git-Bash"><a href="#1-首先安装Git-Bash" class="headerlink" title="1.首先安装Git Bash"></a>1.首先安装Git Bash</h4><p>安装很简单，下载好以后一路点next就ok</p>
<h4 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h4><p>因为hexo是基于nodeJs环境的静态博客，而且还会用到npm工具，所以要安装。</p>
<p>一般下载的话我是选择了LTS版本的，这玩意是长期支持的。安装也是一路next就好了，不过在<code>Custom Setup</code>勾选一下<code>Add Path</code>就免去我们添加环境变量了</p>
<a id="more"></a>

<h4 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h4><p>先创建一个文件夹，用来存放我们博客的所有东西，然后进入这个文件夹内打开Git Bash</p>
<p>一般安装命令是<code>npm install -g hexo-cli</code></p>
<p>但是因为服务器是在国外，网络不好的话就会很难受，可以指定淘宝源</p>
<p><code>npm install -g hexo-cli --registry=https://registry.npm.taobao.org</code></p>
<p>或者临时使用淘宝源</p>
<p><code>npm --registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) install node-red-contrib-composer@latest</code></p>
<p>全局配置淘宝源</p>
<p><code>npm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/)</code></p>
<p>全局配置官方源</p>
<p><code>npm config set registry [http://www.npmjs.org](http://www.npmjs.org/)</code></p>
<p>可以使用<code>npm info underscore</code>查询是否切换到了淘宝源</p>
<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdNgQH.png" class>

<p>或者可以直接安装<code>cnpm</code>工具也可以。</p>
<p>最好还是切换到淘宝源，因为后续还会用到</p>
<h4 id="5-初始化hexo"><a href="#5-初始化hexo" class="headerlink" title="5.初始化hexo"></a>5.初始化hexo</h4><p>使用命令<code>hexo init</code></p>
<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdNIFf.png" class>

<p>初始化结束之后，文件夹里会多出如图的文件和文件夹</p>
<ul>
<li>node_modules : 依赖包</li>
<li>scaffolds : 模板文件夹</li>
<li>source : 存放我们写的文章</li>
<li>themes : 主题</li>
<li>_config.yml : 整个博客的配置文件</li>
</ul>
<h4 id="6-配置GitHub"><a href="#6-配置GitHub" class="headerlink" title="6.配置GitHub"></a>6.配置GitHub</h4><p>首先在GitHub创建一个仓库</p>
<p>在这里对于仓库的有一个规则，必须要符合规则</p>
<p><code>yourname.github.io</code>，其中yourname是你的github名称</p>
<p>创建之后，回到GitBash，配置GitHub账户信息</p>
<p><img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdNHSg.png" alt="1585932600840"></p>
<p>其中<code>user.name</code>后面写的是自己GitHub的名称</p>
<p><code>user.email</code>后面写的是自己的GitHub的邮箱</p>
<p>接下来创建ssh，在GitBash中输入以下命令</p>
<p><code>ssh-keygen -t rsa -C &quot;&quot;</code> 双引号里填入你的GitHub绑定的邮箱</p>
<p>之后输入<code>cd ~/.ssh</code> 接着输入<code>cat id_rsa.sh</code>可以看到ssh        </p>
<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdNqyj.png" class>

<p>将获取到的ssh配置到GitHub上</p>
<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdNzkV.png" class>

<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdUSYT.png" class>

<p>title可以随便取，key就写ssh</p>
<p>可以在GitBash中验证一下<code>ssh -T git@github.com</code></p>
<img src="/2020/04/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-%E7%94%A8hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/GdUCpF.png" class>

<h4 id="7-配置hexo文件（-config-yml）"><a href="#7-配置hexo文件（-config-yml）" class="headerlink" title="7.配置hexo文件（_config.yml）"></a>7.配置hexo文件（_config.yml）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>配置好以后保存</p>
<h4 id="8-启动hexo服务"><a href="#8-启动hexo服务" class="headerlink" title="8.启动hexo服务"></a>8.启动hexo服务</h4><p>这里需要单独安装服务<code>npm i hexo-server</code></p>
<p>还是在blog的文件夹中打开GitBash执行以下命令</p>
<p><code>hexo clean</code></p>
<p><code>hexo generate</code></p>
<p><code>hexo server</code></p>
<p>最后在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>就可以看到hexo了</p>
<h4 id="9-部署到GitHub上"><a href="#9-部署到GitHub上" class="headerlink" title="9.部署到GitHub上"></a>9.部署到GitHub上</h4><p>先安装<code>npm install hexo-deployer-git --save</code></p>
<p>再执行如下命令</p>
<p><code>hexo clean</code></p>
<p><code>hexo generate</code></p>
<p><code>hexo deploy</code></p>
<p>部署好以后会显示</p>
<p><code>INFO  Deploy done: git</code></p>
<p>最后在浏览器输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> （yourname就是GitHub名字）就可以看到hexo搭建的个人博客了</p>
<h4 id="另外-如果出现上传至GitHub后文章图片无法加载的情况"><a href="#另外-如果出现上传至GitHub后文章图片无法加载的情况" class="headerlink" title="另外 : 如果出现上传至GitHub后文章图片无法加载的情况"></a>另外 : 如果出现上传至GitHub后文章图片无法加载的情况</h4><ol>
<li>修改<code>_config.yml</code>文件中</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在我们的hexo根目录下执行</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>之后再使用<code>hexo new &quot;文件名&quot;</code>命令就会创建一个同名文件夹，可以将图片放入这个文件夹里然后插入md</li>
<li>如果还是不行，插入的语法可以使用</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名字 图片描述 %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MySQL</title>
    <url>/2020/05/10/%E5%85%B3%E4%BA%8EMySQL/</url>
    <content><![CDATA[<h3 id="1-什么是MySQL"><a href="#1-什么是MySQL" class="headerlink" title="1.什么是MySQL"></a>1.什么是MySQL</h3><p><a href="https://baike.baidu.com/item/MySQL/471251" target="_blank" rel="noopener">MySQL</a>是一种<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160" target="_blank" rel="noopener">开放源代码</a>的关系型<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">数据库管理</a>系统（RDBMS），使用最常用的数据库管理语言–<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/10450182" target="_blank" rel="noopener">结构化查询语言</a>（SQL）进行数据库管理。</p>
<p>MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的<a href="https://baike.baidu.com/item/%E9%9C%80%E8%A6%81/9109492" target="_blank" rel="noopener">需要</a>对其进行修改。</p>
<p>——百度百科</p>
<p>MySQL的默认端口是3306</p>
<a id="more"></a>

<h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2.存储引擎"></a>2.存储引擎</h3><ol>
<li><strong>查看MySQL提供的存储引</strong>擎</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/10/%E5%85%B3%E4%BA%8EMySQL/1.png" class>

<p>我安装的MySQL是5.7版本的，默认的存储引擎是InnoDB，从图中也可以看出只有InnoDB支持事务。</p>
<ol start="2">
<li><strong>查看默认的存储引擎</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/10/%E5%85%B3%E4%BA%8EMySQL/2.png" class>

<ol start="3">
<li><strong>查看表的存储引擎</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_name'</span></span><br></pre></td></tr></table></figure>

<img src="/2020/05/10/%E5%85%B3%E4%BA%8EMySQL/3.png" class>

<h3 id="3-MyISAM和InnoDB"><a href="#3-MyISAM和InnoDB" class="headerlink" title="3.MyISAM和InnoDB"></a>3.MyISAM和InnoDB</h3><p>在5.5之前MySQL的默认存储引擎一直是MyISAM，之后就换成了InnoDB</p>
<p><strong>区别：</strong></p>
<ol>
<li>InnoDB支持事务，MyISAM不支持事务</li>
<li>InnoDB支持外键，MyISAM不支持外键</li>
<li>InnoDB支持表、行级锁，默认行级锁，MyISAM支持表级锁</li>
<li>InnoDB表必须有主键，MyISAM可以没有</li>
</ol>
<p><strong>如何选择？</strong></p>
<ol>
<li>要支持事务则选择InnoDB，不需要则选择MyISAM</li>
<li>数据大多数为只读数据选择MyISAM，既读又写选择InnoDB</li>
<li>系统崩溃后，相对InnoDB来说，MyISAM恢复更困难</li>
<li>如果不知道选择什么，建议选择InnoDB</li>
</ol>
<p><strong>索引</strong></p>
<ul>
<li><strong>InnoDB：</strong>数据文件本身就是索引文件，是“聚簇索引”，所以必须要有主键。通过主键索引搜索效率高，但辅助索引需要两次查询，先查询到主键，再通过主键查询到主键的数据。</li>
<li><strong>MyISAM：</strong>索引文件和数据文件是分离的，是“非聚簇索引”。索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li>
</ul>
<h4 id="4-查询缓存"><a href="#4-查询缓存" class="headerlink" title="4.查询缓存"></a>4.查询缓存</h4><p>在执行查询语句时，会先查询缓存，没有缓存再查询数据库。在MySQL8.0后被移除</p>
<ol>
<li><strong>查看是否已经开启查询缓存</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query_cache%'</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/10/%E5%85%B3%E4%BA%8EMySQL/4.png" class>

<p><code>query_cache_type</code>为OFF则表示未开启</p>
<p>使用命令开启查询缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global  query_cache_type&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;1代表ON，0代表OFF</span><br></pre></td></tr></table></figure>

<p><strong>开启查询缓存后，在    同样的查询条件和数据的情况下，会直接在查询缓存中返回结果。</strong></p>
<p><strong>查询缓存虽然能提升查询性能，但缓存也带来的额外的开销，既要进行缓存操作，在失效后又要销毁</strong></p>
<h3 id="5-什么是事务"><a href="#5-什么是事务" class="headerlink" title="5.什么是事务"></a>5.什么是事务</h3><p><strong>事务就是逻辑上的一组操作，要么全都执行，要么全都不执行。</strong></p>
<p>最常用的例子就是银行账户转账。比如A给B转账100元，操作成功后应该是A-100，B+100。如果在转账时，银行系统出现故障，A-100，但B并没有+100，这样就不对了。事务就是要保证，这两个操作要么全部成功，要么全部失败。</p>
<ol>
<li><p><strong>事务的4大特性</strong></p>
<ol>
<li><strong>原子性：</strong>事务是最小的执行单位，不允许分割。事务的原子性要全部事务中的所有动作要么全部成功，要么全部失败。</li>
<li><strong>一致性：</strong>执行事务前后，数据保持一致。多个事务对同一个数据的读取结果应该是相同的。</li>
<li><strong>隔离性：</strong>并发访问数据库时，事务之间各自独立，一个事务不会被另一个事务所干扰。</li>
<li><strong>持久性：</strong>一个事务一旦提交，它对数据库的改变是持久的。</li>
</ol>
</li>
<li><p><strong>并发事务会出现的问题</strong></p>
<ol>
<li><strong>脏读：</strong>A事务正在访问数据并对数据进行了修改，但暂未提交。B事务也访问了同一个数据，并且使用了这个数据，但这个数据是A事务尚未提交的，那么这个数据就是“脏数据”，所以对“脏数据”进行的操作也是错误的。</li>
<li><strong>不可重复读：</strong>A事务多次访问同一个数据，在A事务还没结束时，B事务也访问了这个数据，并对数据进行了修改，导致A事务多次读取同一个数据的结果是不一样的，被称为“不可重复读”。</li>
<li><strong>幻读：</strong>和不可重复读类似。在A事务多次访问同一个数据时，在A事务还未结束时，B事务插入了一些数据，并提交。导致在随后的查询中，A事务发现了一些原先不存在的数据。就好像产生了幻觉一般，被称为“幻读”。</li>
</ol>
<p><strong>不可重复读和幻读的区别：</strong></p>
<p>不可重复读的重点在于修改，幻读的重点在于增删。</p>
</li>
</ol>
<h3 id="6-事务的隔离级别"><a href="#6-事务的隔离级别" class="headerlink" title="6.事务的隔离级别"></a>6.事务的隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可能重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ol>
<li><strong>读未提交（READ-UNCOMMITTED）：</strong>最低的隔离级别，允许读取尚未提交的数据。会导致脏读、不可重复读、幻读。</li>
<li><strong>读已提交（READ-COMMITTED）：</strong>允许读取已经提交的数据。不会发生脏读，会导致不可重复读、幻读。</li>
<li><strong>可重复读（REPEATABLE-READ）：</strong>对同一个字段的多次读取结果是一致的，除非数据是被该事务本身所修改。不会发生脏读、不可重复读，会导致幻读。</li>
<li><strong>可串行化（SERIALIZABLE）：</strong>最高的隔离级别。符合事务的4大特性。不会发生脏读、不可重复读、幻读。</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于单点登录的一些总结</title>
    <url>/2020/06/01/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于redis</title>
    <url>/2020/05/16/%E5%85%B3%E4%BA%8ERedis/</url>
    <content><![CDATA[<h3 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1.什么是Redis"></a>1.什么是Redis</h3><p>简单来说Redis就是一个非关系型数据库，不同于MySQL的是它的数据是存储在内存中，因此读写速度非常快，被广泛用作缓存，Redis也被用来做分布式锁。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<p>Redis存储方式为键值对形式。</p>
<a id="more"></a>

<h3 id="2-Redis常见数据类型"><a href="#2-Redis常见数据类型" class="headerlink" title="2.Redis常见数据类型"></a>2.Redis常见数据类型</h3><p>1.<strong>String</strong></p>
<p><strong>常用命令：</strong> set,get,decr,incr,mget 等。</p>
<p>这个数据类型应该是最常见的了，是Key-Value的存储方式。Value不仅仅可以是String，也可以是数字类型。</p>
<p>一般用于计数，例如粉丝数量等。</p>
<p>2.<strong>Hash</strong></p>
<p><strong>常用命令：</strong>hget,hset,hgetall 等。</p>
<p>Hash是一个String的Key和Value的映射表，使用用来存储对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key=User001</span><br><span class="line">value=&#123;</span><br><span class="line">id:<span class="string">"129856296549"</span>,</span><br><span class="line">name:<span class="string">"Java"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.<strong>List</strong></p>
<p><strong>常用命令：</strong> lpush,rpush,lpop,rpop,lrange等。</p>
<p>List是一个链表，一般用于微博的关注列表，粉丝列表等。</p>
<p>List的实现为一个双向链表，支持反向查找和遍历，不过也会带来额外的开销。</p>
<p>可以使用lrange，实现基于List的分页查询。因为该命令就是从某个元素开始读取多少个元素，性能高。</p>
<p>4.<strong>Set</strong></p>
<p><strong>常用命令：</strong>sadd,spop,smembers,sunion 等。</p>
<p>Set使用起来和List类似，不过Set是可以去重的。可以基于这个特性来实现，交集、并集、差集的操作。</p>
<p>比如一些社交软件的共同好友、共同群聊之类的功能。</p>
<p>5.<strong>Zset</strong></p>
<p><strong>常用命令：</strong>zadd、zrange、zrem、zcard 等。</p>
<p>类似Set，不过Zset是可以实现排序的。当需用一个有序并无重复元素的集合可以使用Zset来实现。</p>
<p>比如一些排行榜，还是用微博来举例。微博的热搜排行榜可以使用Zset来实现。</p>
<h3 id="3-使用Redis做缓存"><a href="#3-使用Redis做缓存" class="headerlink" title="3.使用Redis做缓存"></a>3.使用Redis做缓存</h3><p>1.<strong>高性能：</strong></p>
<p>当某个请求第一次访问数据库中的某些数据时，因为是从硬盘中读取，速度会比较慢。如果将这个请求要访问的数据放入Redis缓存中，下次再读取这些数据时，便可以直接从内存中读取，速度相当快。</p>
<p>如果该数据在数据库中有修改，可以删除Redis缓存中的该数据再次存储。</p>
<p>2.<strong>高并发：</strong></p>
<p>直接操作Redis能承受的请求要比数据库大很多，可以把热点数据放入Redis中，减轻数据库的压力。</p>
<p>3.<strong>为什么使用Redis做缓存，而不用map/guava做缓存？</strong></p>
<p>map/guava缓存为本地缓存，特点是轻量、快速、生命周期随着JVM的销毁而结束。在多实例的情况下，会存在多个本地缓存，不具有数据一致性。</p>
<p>Redis可以做分布式缓存，多实例的情况下，使用同一份缓存，可以保持数据的一致性。</p>
<h3 id="4-Redis的淘汰机制"><a href="#4-Redis的淘汰机制" class="headerlink" title="4.Redis的淘汰机制"></a>4.Redis的淘汰机制</h3><p>Redis可以设置一个数据的过期时间，因为大部分存储在Redis中的数据是不需要永久存储的，例如网站的短信验证码，登录用户的Token。</p>
<h5 id="1-Redis的两种删除方式"><a href="#1-Redis的两种删除方式" class="headerlink" title="1.Redis的两种删除方式"></a>1.<strong>Redis的两种删除方式</strong></h5><ul>
<li><p><strong>定性删除：</strong>Redis每间隔100ms就会随机抽取设置了过期时间的数据，检查是否过期，如过期就进行删除。为什么是随机抽取的？因为如果Redis的数据量很大，每间隔100ms就要遍历所有设置了过期时间的数据，会消耗很多资源，给系统带来很大的负载。</p>
</li>
<li><p><strong>惰性删除：</strong>定性删除因为是随机抽取，会存在一些已经过期了的数据没有被抽取到。虽然过期了但却一直存在Redis中。所以惰性删除就是在获取某个数据时，Redis会先检查改数据是否已经过期，如果过期就进行删除。</p>
</li>
</ul>
<p>但这两种机制还不完善，如果定性删除没有抽取到，也没有主动去获取过期数据，那大量的过期数据将存储在Redis中，占用内存。</p>
<p>所以Redis提供了 <strong>内存淘汰机制</strong>。</p>
<h5 id="2-淘汰机制"><a href="#2-淘汰机制" class="headerlink" title="2.淘汰机制"></a>2.淘汰机制</h5><p>Redis提供了6种数据淘汰策略（在4.0版本之后又增加了2种淘汰策略）</p>
<ol>
<li><em>volatile-lru</em>：从已设置过期时间的数据集中，选择<strong>最近最少</strong>使用到的数据进行删除。</li>
<li><em>volatile-ttl</em>：从已设置的过期时间的数据集中，选择<strong>将要过期</strong>的数据进行删除。</li>
<li><em>volatile-random</em>：从已设置过期时间的数据集中，<strong>随机选择</strong>数据进行 删除。</li>
<li><em>allkeys-random</em>：从数据集中，<strong>随机选择</strong>数据进行删除。</li>
<li><em>allkeys-lru</em>：从数据集中，选择<strong>最近最少</strong>使用的数据进行删除。</li>
<li><em>no-eviction</em>：禁止驱逐数据。当内存不足以写入新数据时，直接报错。（这个应该没什么人用…）</li>
<li><em>volatile-lfu</em>：从已设置过期时间的数据集中，选择<strong>使用频率最低</strong>的数据进行删除。</li>
<li><em>allkeys-lfu</em>：从数据集中，选择<strong>使用频率最低</strong>的数据进行删除</li>
</ol>
<p>7和8是新增是2种策略</p>
<h3 id="5-Redis的持久化"><a href="#5-Redis的持久化" class="headerlink" title="5.Redis的持久化"></a>5.Redis的持久化</h3><p>也就是说在Redis挂掉以后怎么恢复数据。</p>
<p>Redis的持久化方式有2种：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file,AOF）</strong>。</p>
<ul>
<li><strong>快照（snapshotting，RDB）：</strong>（是Redis默认的持久化方式）创建快照来获得存储在内存里数据在某个时间点上的副本。在主从结构中，可以将快照复制到别的服务器从而创建具有相同数据的服务器副本。</li>
</ul>
<p>在配置文件.conf中的默认配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只追加文件（append-only file,AOF）：</strong>AOF方式需要手动开启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后，每执行一条更改Redis数据的命令都会存入AOF文件中</p>
<p>AOF分为3种方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>一般选择使用appendfsync everysec，这样既对Redis的性能没有太大影响，又保证了数据的完整性（即使挂掉了也只会丢失1秒的数据）</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于缓存和布隆过滤器</title>
    <url>/2020/05/20/%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1.缓存雪崩"></a>1.缓存雪崩</h3><p><strong>缓存雪崩是什么？</strong></p>
<p>缓存雪崩就是，大量的缓存在同一时间内失效，导致请求落到数据库上，导致数据库在短时间内承受大量的请求而崩溃。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>搭建redis集群，提升高可用性。</li>
<li>将缓存的过期时间设为随机，避免在大量数据在同一时间内失效</li>
<li>将热点数据的过期时间设为永不过期。</li>
</ul>
<a id="more"></a>

<h3 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h3><p><strong>缓存击穿是什么？</strong></p>
<p>缓存击穿就是，缓存中没有但数据库中有的数据。如果这时候并发请求很多，在缓存中读取不到数据，请求就会落到数据库上，导致数据库所承受的压力瞬间增大。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>设置热点数据永不过期。</li>
<li>加锁限流（互斥锁）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCache</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.从缓存中获取数据</span></span><br><span class="line">    String result = getDataFromCache();</span><br><span class="line">    <span class="comment">// 2.如果缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(result)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">                <span class="comment">// 4.拿到锁，从数据库获取数据并写入缓存</span></span><br><span class="line">                result = getDataFromDB();</span><br><span class="line">                setDataToCache(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 6.如果没有拿到锁，先尝试从缓存获取数据（可能别的线程已经将数据写入缓存）</span></span><br><span class="line">                <span class="comment">// 7.如果缓存为空</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(result)) &#123;</span><br><span class="line">                    <span class="comment">// 8.线程sleep一阵</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">// 9.重试</span></span><br><span class="line">                    <span class="keyword">return</span> getCache();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3.缓存穿透"></a>3.缓存穿透</h3><p><strong>缓存穿透是什么？</strong></p>
<p>缓存穿透就是，一个在缓存中和数据库中都不存在的数据。在请求过来时，会直接落到数据库上。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>在接口层面做数据校验。</li>
<li>使用布隆过滤器</li>
<li>在数据库中查询不到也缓存为null值。</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="1-什么是布隆过滤器"><a href="#1-什么是布隆过滤器" class="headerlink" title="1.什么是布隆过滤器"></a>1.什么是布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是1970年由<a href="https://baike.baidu.com/item/%E5%B8%83%E9%9A%86/14216465" target="_blank" rel="noopener">布隆</a>提出的。它实际上是一个很长的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457" target="_blank" rel="noopener">二进制</a>向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。    ——百度百科</p>
<h3 id="2-布隆过滤器的原理"><a href="#2-布隆过滤器的原理" class="headerlink" title="2.布隆过滤器的原理"></a>2.布隆过滤器的原理</h3><p>布隆过滤器有一个<strong>位数组</strong>，位数组的每个元素只占1bit，并且每个元素只能是1或者0</p>
<p><strong>存入元素：</strong></p>
<p>1.布隆过滤器会用哈希函数对元素进行计算，得到哈希值。（有几个哈希函数就会有几个哈希值）</p>
<p>2.根据得到的哈希值，在位数组中把对应的下标设置为1。</p>
<p><strong>判断元素是否存在：</strong></p>
<p>1.使用哈希函数对该元素进行计算，得到哈希值。</p>
<p>2.得到哈希值后，判断位数组中的每个元素对应的下标是否为1。如果都为1则证明该元素在布隆过滤器中，只要有一个不为1，说明该元素不在布隆过滤器中。</p>
<p><strong>结论：</strong>布隆过滤器说某个元素不在，那必定不在；说某个元素存在，有几率会误判。</p>
<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><p>1.过滤，例如防止缓存穿透，一些网站的黑名单功能等。</p>
<p>2.去重</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库和缓存的双写一致性</title>
    <url>/2020/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<p>一般的数据库和缓存的更新策略有3种。</p>
<ol>
<li>先更新数据库，再更新缓存。</li>
<li>先更新数据库，再删除缓存。</li>
<li>先删除缓存，再更新数据库。</li>
</ol>
<a id="more"></a>

<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="1.先更新数据库，再更新缓存"></a>1.先更新数据库，再更新缓存</h3><p>这个应该没什么人用吧。。</p>
<p>原因：</p>
<ol>
<li>线程安全问题：</li>
</ol>
<p>如果短时间内2个请求AB（有先后顺序）进行更新操作。</p>
<ul>
<li>A更新了数据库</li>
<li>B更新了数据库</li>
<li>B更新了缓存</li>
<li>A更新了缓存</li>
</ul>
<p>这里的缓存应该是已B的请求为最新数据，这就导致了脏数据。</p>
<ol start="2">
<li>业务方面</li>
</ol>
<p>如果一个数据频繁更新却很少被读取，浪费性能。</p>
<h3 id="2-先更新数据库，再删除缓存"><a href="#2-先更新数据库，再删除缓存" class="headerlink" title="2.先更新数据库，再删除缓存"></a>2.先更新数据库，再删除缓存</h3><p>如果短时间内有2个请求AB，A进行查询操作，B进行更新操作。</p>
<ul>
<li>缓存刚好失效</li>
<li>A查询缓存发现失效，去查询数据库</li>
<li>B更新数据库</li>
<li>B删除缓存</li>
<li>A将得到的旧值写入缓存</li>
</ul>
<p>这里同样会导致脏数据，还有一种情况</p>
<p>如果短时间内有2个请求AB，A进行更新操作操作，B进行查询操作。</p>
<ul>
<li>A更新了数据库</li>
<li>B查询到了缓存中的旧值直接返回</li>
<li>A删除了缓存</li>
</ul>
<p>这样也会导致脏数据，但影响不大。因为A删除了缓存以后，之后的请求会直接查询数据库，得到的值将会是新数据。</p>
<h3 id="3-先删除缓存，再更新数据库"><a href="#3-先删除缓存，再更新数据库" class="headerlink" title="3.先删除缓存，再更新数据库"></a>3.先删除缓存，再更新数据库</h3><p>如果短时间内有2个请求AB，A进行更新操作，B进行查询操作。</p>
<ul>
<li>A先删除了缓存</li>
<li>B查询缓存发现没有</li>
<li>B查询数据库</li>
<li>B将旧值写入缓存</li>
<li>A更新了数据库</li>
</ul>
<p>这里也会造成脏数据，所以一般采用延时双删策略，别的地方操作一样。</p>
<ul>
<li>A先删除了缓存</li>
<li>B查询缓存发现没有</li>
<li>B查询数据库</li>
<li>B将旧值写入缓存</li>
<li>A更新了数据库</li>
<li>A延时删除缓存</li>
</ul>
<p>至于延时多久可以根据实际场景判断。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>一般我遇到的都是采用第三种方案（先删除缓存，再更新数据库），并采用延时双删策略。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>用户密码的存储方式</title>
    <url>/2020/04/18/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="用户密码的存储方式"><a href="#用户密码的存储方式" class="headerlink" title="用户密码的存储方式"></a>用户密码的存储方式</h3><p>最近正在重构公司的老项目，做到了用户注册这一块的功能。关于用户密码的存储有一些自己的想法，之前也做过，但用的都是MD5算法。突然想学习总结一下关于用户密码的存储方式。</p>
<a id="more"></a>

<h4 id="1-明文存储"><a href="#1-明文存储" class="headerlink" title="1.明文存储"></a>1.明文存储</h4><p>这种是最容易做的，也是最不安全的一种。比如用户的密码是“1234”，就直接原封不动地存到数据库“1234“。但好像大多数互联网公司用的也是这种。。例如顶顶大名的FaceBook之前就被爆出使用明文存储用户密码。</p>
<h4 id="2-对称加密存储"><a href="#2-对称加密存储" class="headerlink" title="2.对称加密存储"></a>2.对称加密存储</h4><p>常见的有</p>
<ul>
<li>DES：数据加密标准，速度较快，适用于加密大量数据的场合；</li>
<li>3DES：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li>AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密。</li>
</ul>
<p>这些方式都有一些共同特征</p>
<ul>
<li>加密和解密都使用同一个密钥</li>
<li>加密解密速度快</li>
<li>密钥传输过程不安全，容易被破解，而且密钥管理麻烦</li>
</ul>
<img src="/2020/04/18/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1.png" class title="对称加密">

<p>一般这种方式，密码和密钥都是分开保存的，但是既然密码泄露了，密钥也不会安全到哪里去。想要密钥绝对的安全应该不是一件易事。</p>
<h4 id="３-使用MD5等单向HASH算法加密存储"><a href="#３-使用MD5等单向HASH算法加密存储" class="headerlink" title="３.使用MD5等单向HASH算法加密存储"></a>３.使用MD5等单向HASH算法加密存储</h4><p>目前正在做的项目就是使用的这一种方式进行加密。应该大部分公司都是使用的这一种，但这种方式不能解密。</p>
<p>听说有一种彩虹表的技术，可以破解这种算法。</p>


<h4 id="４-加盐算法"><a href="#４-加盐算法" class="headerlink" title="４.加盐算法"></a>４.加盐算法</h4><p>在单向加密的基础上，进行加盐，增加破解的难度。但这种”固定盐“的方式，要保证”固定盐“不能被泄露。这里就遇到和对称加密保护密钥一样的问题。”固定盐“泄露了，用彩虹表一样可以破解出密码。</p>
<img src="/2020/04/18/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/3.png" class title="加盐加密">

<h4 id="５-bcrypt算法（属于加盐算法的一种）"><a href="#５-bcrypt算法（属于加盐算法的一种）" class="headerlink" title="５.bcrypt算法（属于加盐算法的一种）"></a>５.bcrypt算法（属于加盐算法的一种）</h4><p>这种算法是比较好的实现方式。在我第一次接触的时候有个疑问：同一个密码但它每次生成的HASH都不一样，那是如何进行校验的？</p>
<p>我查阅资料以后发现：虽然同一个密码每次生成的HASH都不同，但HASH中都包含了“盐”。每次运算都先随机生成一个“盐”，这个“盐”再和密码进行HASH。</p>
<p>在校验的时候，先从HASH中取出“盐”，“盐”再和密码进行HASH，得出的结果和数据库进行对比。</p>
<p>compareSync中已经实现了这一过程：bcrypt.compareSync(password, hashFromDB);</p>
<h4 id="6-PBKDF2算法"><a href="#6-PBKDF2算法" class="headerlink" title="6.PBKDF2算法"></a>6.PBKDF2算法</h4><p>这个是我完全没有接触过的。网上是说该算法原理大致相当于在HASH算法基础上增加“随机盐”，并进行多次HASH运算，“随机盐”使得彩虹表的建表难度大幅增加，而多次HASH也使得建表和破解的难度都大幅增加。使用PBKDF2算法时，HASH算法一般选用sha1或者sha256，“随机盐”的长度一般不能少于8字节，HASH次数至少也要1000次，这样安全性才足够高。</p>
<img src="/2020/04/18/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/4.png" class title="PBKDF2算法">

<h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><table>
<thead>
<tr>
<th>算法</th>
<th>特点</th>
<th>破解方式</th>
<th>破解难度</th>
<th>安全相关</th>
</tr>
</thead>
<tbody><tr>
<td>明文</td>
<td>简单</td>
<td>无需破解</td>
<td>简单</td>
<td>不安全</td>
</tr>
<tr>
<td>对称加密</td>
<td>可以反向破解</td>
<td>需要密钥破解</td>
<td>中等</td>
<td>安全，但要保证密钥不被泄露</td>
</tr>
<tr>
<td>单向HASH</td>
<td>不能反向破解</td>
<td>碰撞、彩虹表</td>
<td>中等</td>
<td>相对安全</td>
</tr>
<tr>
<td>加盐HASH</td>
<td>不能反向破解</td>
<td>碰撞、彩虹表</td>
<td>中等</td>
<td>安全，但要保证盐不被泄露</td>
</tr>
<tr>
<td>PBKDF2算法</td>
<td>不能反向破解</td>
<td>暂时没有</td>
<td>困难</td>
<td>安全</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>工作有感</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习-单例模式</title>
    <url>/2020/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式-单例模式"><a href="#设计模式-单例模式" class="headerlink" title="设计模式-单例模式"></a>设计模式-单例模式</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>单例模式属于创建型设计模式的一种，确保一个类在系统中有且仅有一个实例，会自行实例化，同时向外界提供获取这个唯一实例的方法。</p>
<ul>
<li>单例类有且仅有一个实例</li>
<li>单例类必须自行实例化</li>
<li>向外部提供唯一实例</li>
</ul>
<a id="more"></a>

<h3 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2.优缺点"></a>2.优缺点</h3><ul>
<li>优点<ul>
<li>对于频繁使用的对象，使用单例模式可以减少创建对象所花费的时间</li>
<li>使创建对象的次数减少，减少内存压力</li>
</ul>
</li>
<li>缺点<ul>
<li>单例类没有抽象类，扩展困难</li>
<li>因为只要一个单例，会导致职责过重，违背“单一职责原则”</li>
</ul>
</li>
</ul>
<p><strong>为什么不用静态变量来定义唯一实例呢？</strong></p>
<p>因为静态变量在类加载时便存在，如果没有使用到就会造成资源浪费。使用单例模式的话，可以实现在使用时再创建该实例，避免浪费。</p>
<h3 id="3-关于实现单例模式的几种方法"><a href="#3-关于实现单例模式的几种方法" class="headerlink" title="3.关于实现单例模式的几种方法"></a>3.关于实现单例模式的几种方法</h3><ul>
<li><strong>饿汉式（线程安全，不能实现延迟加载）</strong></li>
</ul>
<p>在类加载时创建单例，免去判断，调用效率高，但也容易造成浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo1 singleton = <span class="keyword">new</span> SingletonDemo1();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供获取方法</span></span><br><span class="line"><span class="comment">     * 没有加synchronized 效率高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>懒汉式（线程不安全，可以延迟加载）</strong></li>
</ul>
<p>区别于饿汉式，这个方式在第一次被使用时创建单例，但在多线程模式下就会出现线程不安全的问题。</p>
<p>可以在<code>getInstance()</code>方法加关键字<code>synchronized</code>，但会让效率低下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SingletonDemo2 singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供获取单例方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟加载</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>懒汉式-双重同步锁（线程安全，可以延迟加载，效率高）</strong></li>
</ul>
<p>第一次检查为了避免不要的实例，第二次检查是为了进行同步。</p>
<p>关于<code>volatile</code>关键字，是保证了数据的可见性，个人的理解是确保多线程下的数据一致性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span>  SingletonDemo3 singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 进入同步代码块以后，再检查一次，为null则创建</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于同步代码块和同步方法，同步方法的范围更大，范围越大性能也就越差。所以第二次懒汉模式性能相对于第一种更好。</p>
<ul>
<li><strong>懒汉式（静态内部类方式，线程安全）</strong></li>
</ul>
<p>只有通过显式调用<code>getInstance()</code>方法，才会显式装载内部类并实例化<code>singleton</code>。只有第一次使用这个单例的实例时才加载，同时不会有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 保证了线程安全</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo4 singleton = <span class="keyword">new</span> SingletonDemo4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供获取实例方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>*<em>饿汉式（枚举方式，线程安全） *</em></li>
</ul>
<p>这种方式用起来很简洁，但我个人不是很喜欢。觉得太简洁了… 可读性不高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton  = Singleton.singleton;</span><br><span class="line">        singleton.testDo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义了一个实例，使用的时候可以直接调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"此方法可以省略，只是为了证明已实例化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-反序列化破坏单例模式"><a href="#4-反序列化破坏单例模式" class="headerlink" title="4.反序列化破坏单例模式"></a>4.反序列化破坏单例模式</h3><p>反序列化会破坏单例模式，会创建一个新的实例</p>
<p><strong>解决方法</strong> : 是重写<code>readResolve()</code>方法，直接返回此方法指定的对象，就不会再单独创建新的实例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper的一些总结</title>
    <url>/2020/06/04/Zookeeper%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-Zookeeper是什么"><a href="#1-Zookeeper是什么" class="headerlink" title="1.Zookeeper是什么"></a>1.Zookeeper是什么</h3><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232" target="_blank" rel="noopener">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429" target="_blank" rel="noopener">分布式应用程序</a>协调服务，是<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>的Chubby一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339" target="_blank" rel="noopener">开源</a>的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。——百度百科</p>
<p>Zookeeper=文件系统+监听通知机制</p>
<a id="more"></a>

<p><strong>Zookeeper的znode</strong></p>
<p>能够自由增加和删除。</p>
<ul>
<li><strong>PERSISTENT-持久化目录节点：</strong>客户端与Zookeeper断开连接后，该节点依然存在。</li>
<li><strong>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点：</strong>同上，只是多了顺序编号</li>
<li><strong>EPHEMERAL-临时目录节点：</strong>客户端与Zookeeper断开连接后，删除该节点。</li>
<li><strong>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：</strong>同上，只是多了顺序编号。</li>
</ul>
<p>临时节点不允许有子节点。</p>
<p><strong>监听通知机制</strong></p>
<p>客户端注册监听它关心的节点，当节点发生变化时（例如数据改变、被删除、增加等）Zookeeper会通知客户端。</p>
<p><strong>Zookeeper的5大特性</strong></p>
<ul>
<li>顺序一致性：同一个客户端发出的请求，会严格按照顺序进入Zookeeper。</li>
<li>原子性：集群中的机器处理某个请求，要么全部成功，要么全部失败。不会出现机器A处理成功，机器B处理失败的情况。</li>
<li>单一性：集群中的所有机器数据一样。</li>
<li>可靠性：服务端数据发生变化会立即存储。</li>
<li>实时性：保证客户端获取到的数据是最新的。</li>
</ul>
<h3 id="2-Zookeeper的集群结构"><a href="#2-Zookeeper的集群结构" class="headerlink" title="2.Zookeeper的集群结构"></a>2.Zookeeper的集群结构</h3><ol>
<li><strong>Leader：</strong>连接任意节点，如果节点出现故障，Leader自动修复，在Service启动时完成Leader的选举。</li>
<li><strong>Follower：</strong>听从Leader的指令，完成选举工作。</li>
<li><strong>Client：</strong>分布式中的一个节点，访问服务器的配置信息，周期性向Server发送心跳包，Server向Client回应确认，如果Client没有收到回应，则重定向至另一个Server。</li>
<li><strong>Server：</strong>Zookeeper的一个节点，为Client提供所需的服务，给Client回应信息表明自己是存活的。</li>
</ol>
<p><strong>Leader的作用：</strong></p>
<ul>
<li>恢复数据</li>
<li>维持与Follower的心跳，接收Follower的请求并判断Follower的请求消息类型。</li>
<li>对不同的Follower消息类型进行不同的处理。</li>
</ul>
<h3 id="3-Zookeeper的基本运转流程"><a href="#3-Zookeeper的基本运转流程" class="headerlink" title="3.Zookeeper的基本运转流程"></a>3.Zookeeper的基本运转流程</h3><ol>
<li>选举Leader</li>
<li>同步数据</li>
<li>选举Leader的算法要保持一致</li>
<li>Leader具有最高的执行ID</li>
<li>集群中的大多数机器得到响应并follow选举出来的Leader</li>
</ol>
<h3 id="4-Zookeeper的一些问题"><a href="#4-Zookeeper的一些问题" class="headerlink" title="4.Zookeeper的一些问题"></a>4.Zookeeper的一些问题</h3><p><strong>Zookeeper服务器挂了，服务调用还可以进行吗？</strong></p>
<p>可以，消费者在启动时会从Zookeeper拉取服务提供者的地址接口等数据，缓存到本地。每次调用时，可以根据本地缓存进行调用。</p>
<p><strong>Zookeeper如何进行服务治理？</strong></p>
<p>接收服务提供者的接口信息和IP地址进行存储，然后管理消费者和服务提供者之间的调用关系。</p>
<p><strong>如果Zookeeper服务挂了怎么办？</strong></p>
<ol>
<li>任意一台挂了，切换到另一台。</li>
<li>全部挂了，消费者和服务提供者可以通过本地缓存进行通讯。</li>
<li>任意一台服务提供者无状态挂了不影响使用。</li>
<li>服务提供者全挂了，消费者无法将无法使用，会无限重连直至服务提供者恢复。</li>
</ol>
]]></content>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Dubbo</title>
    <url>/2020/06/06/%E5%85%B3%E4%BA%8EDubbo/</url>
    <content><![CDATA[<h3 id="1-什么是Dubbo"><a href="#1-什么是Dubbo" class="headerlink" title="1.什么是Dubbo"></a>1.什么是Dubbo</h3><p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：</p>
<ul>
<li>面向接口的远程方法调用</li>
<li>智能容错和负载均衡</li>
<li>服务自动注册和发现。</li>
</ul>
<a id="more"></a>

<h3 id="2-为什么要用Dubbo"><a href="#2-为什么要用Dubbo" class="headerlink" title="2.为什么要用Dubbo"></a>2.为什么要用Dubbo</h3><ul>
<li>公共的逻辑业务提取出来形成服务，对外提供。</li>
<li>方便维护</li>
</ul>
<h3 id="3-Dubbo的节点角色"><a href="#3-Dubbo的节点角色" class="headerlink" title="3.Dubbo的节点角色"></a>3.Dubbo的节点角色</h3><ul>
<li><strong>Provider：</strong>暴露服务的服务提供方</li>
<li><strong>Consumer：</strong>调用远程服务的服务消费方</li>
<li><strong>Registry：</strong>服务注册与发现的注册中心</li>
<li><strong>Monitor：</strong>统计服务的调用次数和调用时间的监控中心</li>
<li><strong>Container：</strong>服务运行的容器</li>
</ul>
<p>整个就是<strong>生产-消费者</strong>模型，并在这种基础上多了<strong>注册中心</strong>和<strong>监控中心</strong>，用于管理服务提供方提供的URL。</p>
<p><strong>运行过程：</strong></p>
<ol>
<li>启动容器，加载并运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心发布注册自己所提供的服务。</li>
<li>服务消费者在启动时，在注册中心订阅自己所需的服务。</li>
</ol>
<p>考虑失败和变更的情况：</p>
<ul>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者从提供者的列表中，基于软负载均衡算法，选择一台提供者调用，如果失败，则另选一台。</li>
<li>消费者和提供者，在内存中累计的调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<p>Dubbo服务之间的调用默认同步阻塞，支持异步调用。</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>win10自带输入法添加小鹤双拼</title>
    <url>/2020/06/07/win10%E8%87%AA%E5%B8%A6%E8%BE%93%E5%85%A5%E6%B3%95%E6%B7%BB%E5%8A%A0%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/</url>
    <content><![CDATA[<p>1.复制文本</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY<span class="emphasis">_CURRENT_</span>USER\Software\Microsoft\InputMethod\Settings\CHS]</span><br><span class="line">"LangBar Force On"=dword:00000000</span><br><span class="line">"Enable Double Pinyin"=dword:00000001</span><br><span class="line">"EmoticonTipTriggerCount"=dword:00000001</span><br><span class="line">"HapLastDownloadTime"=hex(b):eb,69,29,59,00,00,00,00</span><br><span class="line">"UserDefinedDoublePinyinScheme0"="FlyPY<span class="emphasis">*2*</span>^*iuvdjhcwfg xmlnpbksqszxkrltvyovt"</span><br><span class="line">"DoublePinyinScheme"=dword:0000000a</span><br><span class="line">"UDLLastUpdatedTime"="2017-05-27 22:01:40"</span><br><span class="line">"UDLCount"=dword:0000018b</span><br><span class="line">"UDLVisibleCount"=dword:0000018b</span><br></pre></td></tr></table></figure>

<p>2.修改文件后缀为reg</p>
<p>3.双击运行即可</p>
<p>我转载的。</p>
<p>原文链接</p>
<p><a href="https://flypy.com/bbs/forum.php?mod=viewthread&amp;tid=166&amp;highlight=windows" target="_blank" rel="noopener">https://flypy.com/bbs/forum.php?mod=viewthread&amp;tid=166&amp;highlight=windows</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker安装RabbitMQ</title>
    <url>/2020/06/20/%E5%9F%BA%E4%BA%8Edocker%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1.拉取镜像"></a>1.拉取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.7-management</span><br></pre></td></tr></table></figure>

<p>之后可以输入<code>docker images</code>命令查看镜像</p>
<img src="/2020/06/20/%E5%9F%BA%E4%BA%8Edocker%E5%AE%89%E8%A3%85RabbitMQ/1.png" class>

<h3 id="2-创建并启动容器"><a href="#2-创建并启动容器" class="headerlink" title="2.创建并启动容器"></a>2.创建并启动容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name rabbitmq3.7.7 -p 5672:5672 -p 15672:15672 -v `pwd`/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin 2888deb59dfc</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明：</strong><ul>
<li>-d 后台运行</li>
<li>–name  指定容器名字</li>
<li>-p 服务运行端口 5672为应用访问端口 15672为控制台Web端口</li>
<li>-v 映射目录或文件</li>
<li>– hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）</li>
<li>-e 指定环境变量（ABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）</li>
</ul>
</li>
</ul>
<h3 id="3-启动之后查看"><a href="#3-启动之后查看" class="headerlink" title="3.启动之后查看"></a>3.启动之后查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/%E5%9F%BA%E4%BA%8Edocker%E5%AE%89%E8%A3%85RabbitMQ/2.png" class>

<p>输入RabbitMQ控制台地址<code>http://Server-IP:15672</code></p>
]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql索引设计原则</title>
    <url>/2020/06/23/MySql%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="MySQL索引设计原则"><a href="#MySQL索引设计原则" class="headerlink" title="MySQL索引设计原则"></a>MySQL索引设计原则</h3><ol>
<li>对于经常查询的字段，建立索引</li>
<li>选择唯一性索引</li>
<li>选择区别度高的字段，例如性别就不适合做索引</li>
<li>避免对经常更新的表做过多的索引</li>
<li>数据量小的表不建议建立索引，全文检索会比较快</li>
<li>尽量选择数据量少的字段做索引，索引的值不应该太长</li>
<li>为经常需要排序、分组和联合操作的字段建立索引</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
